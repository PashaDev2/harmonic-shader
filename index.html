<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <title>Shader</title>
        <link rel="icon" href="./favicon.ico" type="image/x-icon" />

        <style>
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
                background-color: #000;
            }
        </style>
    </head>
    <body>
        <script defer type="importmap">
            {
                "imports": {
                    "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
                }
            }
        </script>

        <script type="x-shader/x-vertex" id="vertexShader">
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float uTime;
            varying vec2 vUv;

            void main() {
                vNormal = normal;
                vPosition = position;
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        </script>

        <script type="x-shader/x-fragment" id="fragmentShader">
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec4 uMouse;
            varying vec2 vUv;

            float sdCircle( vec2 p, float r ) {
                return length(p) - r;
            }

            const float PERIOD = 4.5;
            const float RADIUS = 0.9;
            const float LINE_WIDTH = 4.;
            const int NUM_LINE_SEGMENTS = 1000;
            const float TILE_MIN = -.5;
            const float TILE_MAX = .5;
            const float PI = 4. * atan(1.);

            // Smooth HSV to RGB conversion
            // https://www.shadertoy.com/view/MsS3Wc
            vec3 hsv2rgb_smooth(float hue, float saturation, float value) {
                vec3 rgb = clamp(abs(mod(hue*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);

                rgb = rgb*rgb*(3.0-2.0*rgb);  // Cubic smoothing

                return value * mix(vec3(1.0), rgb, saturation);
            }

            vec2 curve(float t, float a, float b, float d) {
                return vec2(
                    sin(a * t + d) * cos(t + d),
                    cos(b * t)     * sin(t + d)
                );
            }

            vec2 curvePrime(float t, float a, float b, float d) {
                return vec2(
                    a * cos(a * t + d) * cos(t + d) -     sin(a * t + d) * sin(t + d),
                        cos(b * t)     * cos(t + d) - b * sin(b * t)     * sin(t + d)
                );
            }

            void mainImage(out vec4 fragColor, in vec2 fragCoord) {
                const float numTiles = TILE_MAX - TILE_MIN ;

                float minRes = min(uResolution.x, uResolution.y);
                float scale = float(numTiles) / minRes;

                ivec2 tileCoord = ivec2(round((fragCoord - uResolution.xy * 0.5) * scale));

                vec2 uv = 2. * fragCoord * scale - 2. * vec2(tileCoord) - uResolution.xy * scale;

                // Flip tiles with positive a Y coordinate for symmetry.
                if (tileCoord.y > 0) {
                    uv.y = -uv.y;
                }

                float d = uTime / PERIOD;

                // If the tile coordinates have different parity,
                // only half of the period is needed.
                bool halfPeriod = abs((tileCoord.x * tileCoord.y) % 2) == 1;
                float tPeriod = halfPeriod ? PI : 2. * PI;
                vec2 p1 = curve(0., float(tileCoord.x), float(tileCoord.y), d) * RADIUS;
                float minDist = 1.0;
                float minT;
                float t;
                int numSteps = halfPeriod ? NUM_LINE_SEGMENTS : 2 * NUM_LINE_SEGMENTS;
                for (int i = 1; i <= numSteps; i++) {
                    t = float(i) / float(numSteps) * tPeriod;
                    vec2 p2 = curve(t, float(tileCoord.x), float(tileCoord.y), d) * RADIUS;

                    // Distance to line
                    vec2 pa = uv - p2;
                    vec2 ba = p1 - p2;

                    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);

                    vec2 q = pa - ba * h;

                    float dist = dot(q, q);
                    if (dist < minDist) {
                       minDist = dist;
                       minT = (float(i) - h) / float(numSteps) * tPeriod;
                    }
                    p1 = p2;
                }

                t = minT;

                float v = smoothstep(LINE_WIDTH * scale, 0.0, sqrt(minDist));
                fragColor = vec4(vec3(v), 1.0);
            }

            void main() {
                vec2 uv = vUv;
                uv.x += 4.1;
                uv.y += 13.0;

                vec2 p = (2.0 * gl_FragCoord.xy - uResolution) / min(uResolution.x, uResolution.y);
                float circle = sdCircle(p, 0.8) * 1.5;


                // draw circle border
                float b = smoothstep(0.0, 0.01, abs(circle));
                vec3 color = mix(vec3(1.0, 1.0, 1.0), vec3(.0, .0, .0), b);

                // Spheric harmonics of the third degree
                if(circle < 0.0) {
                    mainImage(gl_FragColor, uv * uResolution);
                } else {
                    gl_FragColor = vec4(color,1.0);
                }

                #include <tonemapping_fragment>
                #include <colorspace_fragment>
            }
        </script>

        <!-- <script type="x-shader/x-vertex" id="vertexShader">
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float uTime;
            varying vec2 vUv;

            void main() {
                vNormal = normal;
                vPosition = position;
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        </script>

        <script type="x-shader/x-fragment" id="fragmentShader">
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec4 uMouse;
            varying vec2 vUv;

            float sdCircle( vec2 p, float r ) {
                return length(p) - r;
            }

            void main() {
                vec2 uv = vUv;

                gl_FragColor = vec4(uv, 0.0, 1.0);


                #include <tonemapping_fragment>
                #include <colorspace_fragment>
            }
        </script> -->

        <script type="module" src="index.js"></script>
    </body>
</html>
